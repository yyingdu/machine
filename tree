'''
Created on 2019年3月25日

@author: 杜莹
'''
# -*-coding:utf-8-*-
from sklearn.feature_extraction import DictVectorizer
import csv
from sklearn import preprocessing
from sklearn import tree
from sklearn.externals.six import StringIO
from matplotlib.pyplot import clf

#sklearn要求处理的数据必须要是数值类型
#搭建一个矩阵用1 0代替本值
allElectronicsData = open("play.csv",'rt')
reader = csv.reader(allElectronicsData)
headers =next(reader)

print(headers)
#建立俩个列表
featureList = []
labelList = []
#将表格中的数据按照0，1矩阵的格式存储下来
for row in reader:
    labelList.append(row[len(row)-1])
    rowDict = {}
    for i in range(1,len(row)-1):
        #print(row[1])
        rowDict[headers[i]] = row[i]
        #print("rowDict: ",rowDict)
    featureList.append(rowDict)

#转换成想要的格式
print(featureList)

#vectorize feature
vec = DictVectorizer()
dumpyX = vec.fit_transform(featureList).toarray()

print("dunmpyX "+ str(dumpyX) )
print("feature_name"+str(vec.get_feature_names()))

print("labelList "+ str(labelList))

#vectorize class lables
lb = preprocessing.LabelBinarizer()
#把列标记转换为0，1的固定函数
dummyY = lb.fit_transform(labelList)
print("dummyY:" +str(dummyY))
#构建好决策树
clf = tree.DecisionTreeClassifier(criterion='entropy')
clf = clf.fit(dumpyX,dummyY) #构造决策树

#打印构造决策树采用的参数
print("clf : "+str(clf))
#创建dot文件
with open('all.dot','w')as f:
    f= tree.export_graphviz(clf, feature_names=vec.get_feature_names(),out_file = f)
#再利用cmd将dot格式转换为pdf格式
#输入测试数据
#取表中的第一行数据
oneRowX=dumpyX[0,:]
print("oneRowX: "+str(oneRowX))

newRowX = oneRowX
newRowX[0]=1
newRowX[2]=0
print("newRowX:"+str(newRowX))

predictedY = clf.predict([newRowX])
print("predictedY:"+str(predictedY))
